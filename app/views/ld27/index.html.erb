<p class="text-center lead">
  Welcome to Astronomical Odds, the spaceport invasion last-stand simulator.
</p>
<p class="text-center"> This game was created in Ludum Dare 27 using theme '10 Seconds'. Ludum Dare
  is a game development competition where participants have 48 hours to make a game from scratch.
</p>

<div class='hero-unit'>
  <div class="text-center game-area">
    <div class="stats"></div><br />
      <a href="javascript:GameState.start({});" class="btn btn-large btn-primary">Play The Game!</a>
  </div>
</div>
<!--Yes this is all inline. I should optimize but I just extracted it from a prior project.-->
<style type='text/css'>

/* Generated by Font Squirrel (http://www.fontsquirrel.com) on April 27, 2013 */
@font-face {
    font-family: 'electrolizeregular';
    src: url('/staticassets/electrolize-regular-webfont.eot');
    src: url('/staticassets/electrolize-regular-webfont.eot?#iefix') format('embedded-opentype'),
         url('/staticassets/electrolize-regular-webfont.woff') format('woff'),
         url('/staticassets/electrolize-regular-webfont.ttf') format('truetype'),
         url('/staticassets/electrolize-regular-webfont.svg#electrolizeregular') format('svg');
    font-weight: normal;
    font-style: normal;
}

.hero_unit *{
  font-family: "electrolizeregular" !important
}
</style>
<script>

var GameController = {
  init:function(token)
  {
    GameModel.init(token);
    GameView.init();
    GameModel.gameTimer = setInterval(GameController.loop,(1000/GameModel.stats.MAX_FPS));
  },
  loop:function()
  {
    
    GameModel.frame();
    GameView.frame();
    GameModel.benchmarkEnd();
    GameModel.benchmarkStart();
  }
}

var GameModel = {
  token: null,
  gameTimer: null, //timer to clear when not in game!
  turnCount:0,
  stats: {
    MAX_FPS:30,
    computedFrames:0,
    timeStart:null,
    timeEnd:null,
    frameTime:0,
    fps:0
  },
  minimap:{
    MIN_X:-10000,
    MAX_X:10000,
    MIN_Y:-10000,
    MAX_Y:10000,
    ZOOM:200 
  },
  rendering: {
    MIN_ZOOM:0.4,
    MAX_ZOOM:1,
    mode:'ui', //ui or game.
    zoom:1
  },
  bases: {
    levelupRepair:0.1,
    repairTick: 150,
    enemyWaveTick: 1000, //overriden
    pickups:{
      shotgun:0.02,  //chance of spawn per roll
      sprayer:0.025,
      laser:0.03,
      decimator:0.015,
      dual: 0.04,
      triple: 0.03,
      explosion: 0.01,
      sweeper: 0.01,
      sonicboom: 0.015,
      heal: 0.2
    },
    healBase: 2,
    healLevel: 2,
    pickupDeath:70 //do70 dicerolls for pickup generation once this building is dead
  },
  enemies:{
    basic:{
      initialChance:1.00,
      levelChance:0.1,
      initialQty:1,
      levelQty:1,
      drop:{
        red: {
          chance: 0.015,
          amount: 20,
          amountRandom: 50,
          amountLevel: 3,
          amountLevelSquared: 1
        },
        green: {
          chance: 0.01,
          amount: 10,
          amountRandom: 30,
          amountLevel: 1,
          amountLevelSquared: 1
        },
        blue: {
          chance: 0.005,
          amount: 5,
          amountRandom: 10,
          amountLevel: 0.5,
          amountLevelSquared: 1
        }
      }
    },
    fat:{
      initialChance:0.00,
      levelChance:0.05,
      initialQty:1,
      levelQty:0.5,
      drop:{
        red: {
          chance: 0.01,
          amount: 40,
          amountRandom: 100,
          amountLevel: 5,
          amountLevelSquared: 3
        },
        green: {
          chance: 0.005,
          amount: 30,
          amountRandom: 50,
          amountLevel: 2,
          amountLevelSquared: 2
        },
        blue: {
          chance: 0.002,
          amount: 10,
          amountRandom: 20,
          amountLevel: 1,
          amountLevelSquared: 1
        }
      }
    },
    scion:{
      initialChance:-0.02,
      levelChance:0.04,
      initialQty:1,
      levelQty:0.2,
      drop:{
        red: {
          chance: 0.03,
          amount: 300,
          amountRandom: 200,
          amountLevel: 6,
          amountLevelSquared: 7
        },
        green: {
          chance: 0.02,
          amount: 100,
          amountRandom: 150,
          amountLevel: 6,
          amountLevelSquared: 6
        },
        blue: {
          chance: 0.01,
          amount: 50,
          amountRandom: 70,
          amountLevel: 4,
          amountLevelSquared: 3
        }
      }
    },
    shard:{
      initialChance:-0.05,
      levelChance:0.02,
      initialQty:2,
      levelQty:0.5,
      drop:{
        red: {
          chance: 0.08,
          amount: 600,
          amountRandom: 500,
          amountLevel: 20,
          amountLevelSquared: 9
        },
        green: {
          chance: 0.04,
          amount: 250,
          amountRandom: 300,
          amountLevel: 15,
          amountLevelSquared: 7
        },
        blue: {
          chance: 0.02,
          amount: 100,
          amountRandom: 100,
          amountLevel: 10,
          amountLevelSquared: 5
        },
      }
    }
  },
  input: {
    keyboard: {
      w:false,
      s:false,
      a:false,
      d:false,
      left_arrow:false,
      right_arrow:false,
      up_arrow:false,
      down_arrow:false,
      space:false
    }
  },
  init:function(token) {
    this.token = token;
    GameModel.bases.enemyWaveTick = (GameModel.stats.MAX_FPS * 10)
    GamePlayer.init();
    GameMinimap.init();
    GameNPCBases.init();
    GamePickups.init();
    GameBigText.init();
  },
  frame:function(){
    this.stats.computedFrames++;
    //this.rendering.zoom = 0.6 + (0.4*Math.sin(this.stats.computedFrames/100)); //TEST
    //logical steps.
    this.recalculateZoom();
    GameDirector.logic();
    GamePlayer.logic();
    GameEnemies.logic();
    GameBullets.logic();
    GameViewParticles.logic();
    GameViewDamageText.logic();
    GameNPCBases.logic();
    GamePickups.logic();
    GameBigText.logic();
  },
  recalculateZoom:function()
  {
    var velocityRatio = GamePlayer.ship.velocity() / GamePlayer.ship.maxThrust
    var amp =(GameModel.rendering.MAX_ZOOM - GameModel.rendering.MIN_ZOOM)
    GameModel.rendering.zoom = GameModel.rendering.MAX_ZOOM - Math.sin(0.5 * Math.PI * velocityRatio) * amp

  },
  benchmarkStart:function() {
    this.stats.timeStart = new Date().getTime()
  },
  benchmarkEnd:function(){
    this.stats.timeEnd = new Date().getTime()
    this.stats.frameTime = this.stats.timeEnd - this.stats.timeStart
    if(this.stats.frameTime > 0 )
    {
      this.stats.fps = Math.round(1000/this.stats.frameTime)
    }
  }
}

var GameState = {
  state: 'init',
  currency: {
    red: 0,
    green: 0,
    blue: 0
  },
  setGameOver:function()
  {
    this.state = 'gameover'; 
    clearInterval(GameModel.gameTimer);
    $('.game-area').html("<h1 class=\"lead\">Game Over.</h1><!--<div id=\"saveStatus\"></div>--><div class=\"stats\"></div><a class=\"btn btn-large btn-primary\" href=\"javascript:location.reload(true)\"");
    //$('#saveStatus').addClass("alert alert-warning");
    //$('#saveStatus').text("Not Yet Saved!")
    //this.save();
  },
  start:function(token)
  {
    this.state = 'ingame'; 
    $('.game-area').html("<canvas id=\"game\" width=\"800\" height=\"600\"></canvas>")
    GameController.init(token);
  },
}

var GameView = {
  WINDOW_WIDTH:800,
  WINDOW_HEIGHT:600,
  ctx:null,

  init:function(){
    var c=$('#game')[0];
    window.addEventListener("keydown",GameKeyListener.keyDown,true);
    window.addEventListener("keyup",GameKeyListener.keyUp,true);
    var ctx=c.getContext('2d');
    this.ctx = ctx;
    GameViewParticles.init();
    ctx.font="20px electrolizeregular";
  },
  frame:function()
  {
    this.frameClean();
    
    GameViewParticles.frame(this.ctx);
   
    //render objects.
    GameNPCBases.render(this.ctx);
    GamePickups.render(this.ctx);
    GamePlayer.render(this.ctx);
    GameEnemies.frame(this.ctx);
    GameViewDamageText.render(this.ctx);


    GameMinimap.frame(this.ctx);
    GameViewUI.frame(this.ctx);
    GameBullets.render(this.ctx);
    GameBigText.render(this.ctx);
    
  },
  frameClean:function()
  {
    this.renderModeUI();
    this.ctx.fillStyle="#000000";  
    this.ctx.fillRect(0,0,800,600);
  },
  renderModeUI:function()
  {
    this.ctx.setTransform(1,0,0,1,-0.5,-0.5)
    GameModel.rendering.mode = 'ui'
  },
  renderModeGame:function()
  {
    this.ctx.setTransform(
      GameModel.rendering.zoom,
      0,
      0,
      GameModel.rendering.zoom,
      -0.5 + ((0.5*(GameView.WINDOW_WIDTH))  - ((GamePlayer.ship.x)) * GameModel.rendering.zoom),
      -0.5 + ((0.5*(GameView.WINDOW_HEIGHT)) - ((GamePlayer.ship.y)) * GameModel.rendering.zoom)
    )
    GameModel.rendering.mode='game'
  }
}

var GameKeyListener = {
  keyDown:function(e)
  {
    GameKeyListener.setKey(e, true)
  },
  keyUp:function(e)
  {
    GameKeyListener.setKey(e, false)
  },
  setKey:function(e, state)
  {
    var map = GameModel.input.keyboard
    switch(e.keyCode)
    {
      case 87: 
        map.w = state
        e.preventDefault();
      break;
      case 83:
        map.s = state
        e.preventDefault();
      break;
      case 65:
        map.a = state
        e.preventDefault();
      break;
      case 68: 
        map.d = state
        e.preventDefault();
      break;
      case 32: 
        map.space = state
        e.preventDefault();
      break;
      case 37: 
        map.left_arrow = state
        e.preventDefault();
      break;
      case 38: 
        map.up_arrow = state
        e.preventDefault();
      break;
      case 39: 
        map.right_arrow = state
        e.preventDefault();
      break;
      case 40: 
        map.down_arrow = state
        e.preventDefault();
      break;
    }
    GameModel.input.keyboard = map
  }
}

var GameBigText={
  title:'',
  subtitle:'',
  color:'255,255,255',
  alpha:1,
  calledAt:0,
  show:false,
  init:function()
  {
    GameBigText.setText('enemies detected','hyperspace jumps imminent','255,0,0',5);
  },
  setText:function(title, subtitle, color, time)
  {
    this.title = title
    this.subtitle = subtitle
    this.color = color
    this.alpha = 1
    this.calledAt = GameModel.stats.computedFrames 
    time = time || 5
    this.totalFrames = time * GameModel.stats.MAX_FPS
    this.show = true;
  },
  render:function(ctx)
  {
    GameView.renderModeUI();
    if(this.show)
    {
      ctx.font="80px electrolizeregular";
      ctx.strokeStyle="rgba("+this.color+","+this.alpha+")";
      ctx.fillStyle="rgba("+this.color+","+this.alpha+")";
      ctx.textAlign = 'center'
      ctx.fillText(this.title, GameView.WINDOW_WIDTH/2, GameView.WINDOW_HEIGHT/2 - 40);
      ctx.font="40px electrolizeregular";
      ctx.fillText(this.subtitle, GameView.WINDOW_WIDTH/2, GameView.WINDOW_HEIGHT/2 + 60);
      ctx.font="20px electrolizeregular";
    }
  },
  logic:function()
  {
    if(this.show)
    {
      var ratioDone = ((GameModel.stats.computedFrames - this.calledAt) / this.totalFrames) 
      if(ratioDone >= 1)
      {
        this.show = false
      }
      else {
        this.alpha=Math.cos(0.5*Math.PI*ratioDone) * 0.4; //base;
      }
    }
  }
}

GameViewDamageText = {
  texts:[],
  render:function(ctx)
  {
    GameView.renderModeGame();
    var i = this.texts.length;
    while (i--) {
      text = this.texts[i]; 
      ctx.fillStyle="rgba("+text.color+","+text.alpha+")"; 
      ctx.textAlign = 'center'
      ctx.fillText(text.text, text.x, text.y);
    } 
  },
  logic:function()
  {
    var i = this.texts.length
    while (i--) {
      text = this.texts[i]; 
      if(text.frameTotal + text.frameStarted < GameModel.stats.computedFrames)
      {
        this.texts.splice(i, 1);
      } else
      {
        text.y = text.y + text.velocityY;

        if(text.frameTotal + text.frameRampUp > GameModel.stats.computedFrames)
        {
          text.alpha = text.alpha + (1 / text.frameRampUp)
        } else {
          var rampDownProportion = (GameModel.stats.computedFrames - text.frameStarted ) / (text.frameTotal) 
          
          text.alpha = Math.round(Math.pow(Math.cos(0.5* Math.PI * rampDownProportion),2)*1000)/1000;
        }
      }
    }
  },
  addDamageText:function(target, bullet, damage)
  {
    var text= {
      color: bullet.color,
      text: damage,
      x: target.x,
      y: target.y - (0.5)*target.height,
      alpha: 0,
      frameStarted: GameModel.stats.computedFrames,
      frameRampUp: 10,
      frameTotal: 60,
      velocityY: -3
    }
    this.texts.push(text);
  }
}

var GameMinimap={
  SIZE:100,
  buffer:{
    canvas:null,
    ctx: null
  },
  init:function()
  {
    this.buffer.canvas = document.createElement('canvas');
    this.buffer.ctx = this.buffer.canvas.getContext('2d');
    this.buffer.canvas.width = this.SIZE;
    this.buffer.canvas.height = this.SIZE;
    this.buffer.canvas.fillStyle = '#000';
  },
  frame:function(ctx)
  {

    GameView.renderModeUI();
    ctx.translate(GameView.WINDOW_WIDTH-this.SIZE, GameView.WINDOW_HEIGHT-this.SIZE)

    if(GameNPCBases.alive['radar']) { //TODO
      this.renderOutline(ctx);
      //load objects.
      
      this.renderEnemies(ctx);
      this.renderBases(ctx);
      this.renderPlayer(ctx);
      this.renderPickups(ctx);
    } else {
      this.renderBroken(ctx);
    }

    //border outline
    ctx.strokeStyle='#ffffff';
    ctx.strokeRect(
      0,
      0,
      this.SIZE,
      this.SIZE
    )
  },
  renderOutline:function(ctx)
  {
    //border bg
    ctx.fillStyle='#000000';
    ctx.fillRect(
      0,
      0,
      this.SIZE,
      this.SIZE
    );
    //circle outlines
    for(var i=1;i<=4;i++)
    {
      ctx.strokeStyle="#333333";
      ctx.beginPath();
      ctx.arc(
        this.SIZE/2, 
        this.SIZE/2, 
        i*12.5, 
        0, 
        Math.PI*2, 
        true
      ); 
      ctx.closePath();
      ctx.stroke();
    };
  },
  //https://github.com/bahamas10/tvstatic/
  renderBroken:function(ctx)
  {

    //border bg
    ctx.fillStyle='#666666';
    ctx.fillRect(
      0,
      0,
      this.SIZE,
      this.SIZE
    );
    scale = 1;
    var h = this.SIZE;
    var w = this.SIZE;

    this.buffer.ctx.clearRect(0, 0, this.SIZE, this.SIZE);
    // draw the static on the buffer canvas
    for (var x = 0; x < this.SIZE; x+=scale) {
      for (var y = 0; y < this.SIZE; y+=scale) {
        if (Math.round(Math.random()))
          this.buffer.ctx.fillRect(x, y, scale, scale);
      }
    }

    // repeat it onto the real canvas
    for (var x = 0; x < this.SIZE; x += this.SIZE) {
      for (var y = 0; y < this.SIZE; y += this.SIZE) {
        ctx.drawImage(this.buffer.canvas, x, y);
      }
    }

    // draw some horizontal lines on the real canvas
    for (var y = Math.floor(Math.random() * 10); y < this.SIZE; y += Math.floor(Math.random() * 10)) {
      ctx.fillRect(0, y, this.SIZE, Math.floor(Math.random() * 3));
    }
  },
  renderPlayer:function(ctx)
  {
    if(this.withinBounds(GamePlayer.ship))
    {
      ctx.fillStyle="rgb("+GamePlayer.ship.color+")";
      ctx.fillRect(
        GamePlayer.ship.x/GameModel.minimap.ZOOM + 0.5 * this.SIZE -1,
        GamePlayer.ship.y/GameModel.minimap.ZOOM + 0.5 * this.SIZE -1,
        3,
        3
      );
    }
  },
  renderEnemies:function(ctx)
  {
    for(var i=0; i<GameEnemies.enemies.length;i++)
    {
      enemy = GameEnemies.enemies[i].ship;
      if(this.withinBounds(enemy))
      {
        ctx.fillStyle="rgb("+enemy.color+")";
        ctx.fillRect(
          enemy.x/GameModel.minimap.ZOOM + 0.5 * this.SIZE -1,
          enemy.y/GameModel.minimap.ZOOM + 0.5 * this.SIZE -1,
          3,
          3
        );
      }
    }
  },
  renderPickups:function(ctx)
  {
    for(var i=0; i<GamePickups.pickups.length;i++)
    {
      pickup = GamePickups.pickups[i];
      if(this.withinBounds(pickup))
      {
        ctx.fillStyle="rgb("+pickup.color+")";
        ctx.fillRect(
          pickup.x/GameModel.minimap.ZOOM + 0.5 * this.SIZE -1,
          pickup.y/GameModel.minimap.ZOOM + 0.5 * this.SIZE -1,
          3,
          3
        );
      }
    }
  },
  renderBases:function(ctx)
  {
    for(var i=0; i<GameNPCBases.bases.length;i++)
    {
      base = GameNPCBases.bases[i];
      if(this.withinBounds(base))
      {
        ctx.fillStyle="rgb("+base.color+")";
        ctx.fillRect(
          base.x/GameModel.minimap.ZOOM + 0.5 * this.SIZE -1,
          base.y/GameModel.minimap.ZOOM + 0.5 * this.SIZE -1,
          3,
          3
        );
      }
    }
  },
  withinBounds:function(obj)
  {
    return (
      obj.x < GameModel.minimap.MAX_X &&
      obj.x > GameModel.minimap.MIN_X &&
      obj.y < GameModel.minimap.MAX_Y &&
      obj.y > GameModel.minimap.MIN_Y 
    )
  },
  logic:function()
  {
  }

}

GameViewParticles = {
  STAR_COUNT:3000,
  stars:[],
  thrust:[],
  MIN_X:null,
  MIN_Y:null,
  MAX_X:null,
  MAX_Y:null,
  STARFIELD_WIDTH:null,
  STARFIELD_HEIGHT:null,
  init:function()
  {
    //set maximum bounds for the particles to be within, based on max zoomage.
    this.MIN_X = -2000
    this.MAX_X = 2000
    this.MIN_Y = -2000
    this.MAX_Y = 2000
    this.STARFIELD_WIDTH  = this.MAX_X - this.MIN_X
    this.STARFIELD_HEIGHT = this.MAX_Y - this.MIN_Y
    for(var i=0;i<this.STAR_COUNT;i++)
    {
      var star = {};
      this.initStar(star);
      this.stars.push(star)
    }
  },

  frame:function(ctx)
  {

    GameView.renderModeUI()
    ctx.fillStyle="rgb(255,255,255)";
    for(var i=0;i<this.stars.length;i++)
    {
      var star = this.stars[i];
      this.frameStar(ctx, star);
    }
    GameView.renderModeGame()
    for(var i=0;i<this.thrust.length;i++)
    {
      var part = this.thrust[i];
      this.frameThrust(ctx, part);
    }

  },
  initStar:function(star)
  {
    star.z = 3 + Math.round(Math.random()*9); //apply square power later when scrolling.
    star.x = Math.round((Math.random()*this.STARFIELD_WIDTH)  + this.MIN_X);
    star.y = Math.round((Math.random()*this.STARFIELD_HEIGHT) + this.MIN_Y);
      
  },
  frameStar:function(ctx, star)
  {
      //TO REVISIT: Parallax Scrolling!
      //      if(star.y-(GamePlayer.ship.y) > this.MAX_Y){
      //        star.y = star.y - (this.STARFIELD_HEIGHT);
      //      }
      //      if(star.y-(GamePlayer.ship.y) < this.MIN_Y){
      //        star.y = star.y + (this.STARFIELD_HEIGHT);
      //      }
      //      if(star.x-(GamePlayer.ship.x) > this.MAX_X){
      //        star.x = star.x - (this.STARFIELD_WIDTH);
      //      }
      //      if(star.x-(GamePlayer.ship.x) < this.MIN_X){
      //        star.x = star.x + (this.STARFIELD_WIDTH);
      //      }

      ctx.beginPath();
      ctx.arc(
        (star.x- (GamePlayer.ship.x/star.z)), 
        (star.y- (GamePlayer.ship.y/star.z)), 
        0.5 + ((10-star.z)/10), 
        0, 
        Math.PI*2, 
        true
      ); 
      ctx.closePath();
      ctx.fill();
  },
  frameThrust:function(ctx, thrust)
  {
      ctx.fillStyle="rgba("+thrust.color+","+thrust.alpha+")"
      ctx.translate(thrust.x, thrust.y);
      ctx.rotate(thrust.rot);
      ctx.fillRect(
        thrust.xOffset-0.5,
        thrust.yOffset-0.5,
        2,
        10
      )

      ctx.rotate(-thrust.rot);
      ctx.translate(-thrust.x, -thrust.y);
      
  },
  addThrust:function(ship,xOffset, yOffset)
  {
    xOffset = xOffset || 0;
    yOffset = yOffset || 0;
    this.thrust.push({
      x: ship.x,
      y: ship.y,
      xOffset: xOffset + 0,
      yOffset: yOffset + ship.height/4,
      rot: ship.rot + (((Math.random()*30)-15)/180*Math.PI),
      color: "255,"+(Math.round(Math.random()*200)+55).toString()+",0",
      alpha: 0.7
    })
  },
  logic:function()
  {
    var i = this.thrust.length
    while (i--) {
      this.thrust[i].alpha=this.thrust[i].alpha * 0.97
      if(this.thrust[i].alpha <= 0.01)
      {
        this.thrust.splice(i, 1);
      }
    }
  }
}

var GameViewUI = {
  BAR_WIDTH:GameView.WINDOW_WIDTH-150,
  frame: function(ctx)
  {
    GameView.renderModeUI()

    ctx.fillStyle="#ffffff";  

    ctx.textAlign = 'center'
    ctx.fillText("["+Math.round(GamePlayer.ship.x)+","+Math.round(GamePlayer.ship.y)+"]", GameView.WINDOW_WIDTH/2, GameView.WINDOW_HEIGHT-5);

    
    ctx.fillStyle = '#660000'
    ctx.fillRect(
      5,
      7,
      this.BAR_WIDTH,
      22
    )
    ctx.fillStyle = '#006600'
    ctx.fillRect(
      5,
      7,
      this.BAR_WIDTH*(GamePlayer.ship.HP/GamePlayer.ship.HPmax),
      22
    )

    ctx.fillStyle = '#660000'
    ctx.fillRect(
      5,
      30,
      this.BAR_WIDTH*(1-((GameModel.stats.computedFrames % GameModel.bases.enemyWaveTick)/(GameModel.bases.enemyWaveTick))),
      6
    )

    ctx.fillStyle = '#666600'
    ctx.fillRect(
      5,
      37,
      (GamePlayer.ship.auxAmmoMax==0) ? 0 : this.BAR_WIDTH * (GamePlayer.ship.auxAmmo / GamePlayer.ship.auxAmmoMax),
      6
    )

    ctx.fillStyle = '#ffffff' 
    ctx.textAlign = 'right'
    ctx.fillText("hull: "+Math.round(GamePlayer.ship.HP)+"/"+Math.round(GamePlayer.ship.HPmax)+"", this.BAR_WIDTH-5, 25);

    ctx.textAlign = 'right'
    ctx.fillText(Math.round(GamePlayer.ship.velocity())+" Gm/s", GameView.WINDOW_WIDTH-10, 25);

    var enemyCount = GameEnemies.enemies.length;
    ctx.textAlign = 'left'
    ctx.fillText("Wave "+GameModel.turnCount+"/"+enemyCount+" enemies detected", 10, GameView.WINDOW_HEIGHT-5);

    ctx.textAlign = 'right'
    ctx.fillText(GameModel.stats.fps+" fps", GameView.WINDOW_WIDTH-110, GameView.WINDOW_HEIGHT-5);

    ctx.textAlign = 'right'
    ctx.strokeStyle = '#ffffff'
    ctx.fillStyle = '#ff0000';
    ctx.fillText("x "+pad(GameState.currency.red,4), GameView.WINDOW_WIDTH-10, GameView.WINDOW_HEIGHT-145); 
    
    ctx.fillStyle = '#00ff00';
    ctx.fillText("x "+pad(GameState.currency.green,4), GameView.WINDOW_WIDTH-10, GameView.WINDOW_HEIGHT-125);

    ctx.fillStyle = '#0000ff';
    ctx.fillText("x "+pad(GameState.currency.blue,4), GameView.WINDOW_WIDTH-10, GameView.WINDOW_HEIGHT-105);
    ctx.strokeRect(GameView.WINDOW_WIDTH-100,GameView.WINDOW_HEIGHT-165, 100, 65);
    
  }
}
    

function pad(n, width, z) {
  z = z || '0';
  n = n + '';
  return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;
}

var GameNPCBase= function(x, y, w, h, color, type, faction){
  this.HP = 250;
  this.HPmax = 250;
  this.x = x;
  this.y = y;
  this.width = w;
  this.height = h;
  this.collidableSphereRad = (h/2);
  this.deathAnimLength = 150;
  this.color = color;
  this.type = type || 'basic';
  this.rot = 0;
  this.faction = faction || 'good'; 
  this.killedAt = null;
  this.design = [
    { x:-0.5,  y:-0.5  },
    { x:-0.5,  y: 0.5  },
    { x: 0.5,  y: 0.5  },
    { x: 0.5,  y:-0.5  },
    { x:-0.5,  y:-0.5  },
  ];
  this.alpha = 1; //cloak?


  this.render = function(ctx)
  {
    GameView.renderModeGame();
    ctx.translate(this.x, this.y);
   
    if(this.killedAt !== null)
    {
      if(GameModel.stats.computedFrames - this.killedAt < this.deathAnimLength)
      {
        var animProportion = ((GameModel.stats.computedFrames - this.killedAt) / this.deathAnimLength)
        this.alpha = Math.round(Math.pow(Math.cos(0.5* Math.PI * animProportion),2)*1000)/1000;
      } else {
        this.alpha = 0;
      }
    }
    ctx.fillStyle="rgba(0,0,0,"+this.alpha+")";
    ctx.strokeStyle="rgba("+this.color+","+this.alpha+")";
    
    w = this.width
    h = this.height

    
    ctx.beginPath();
    ctx.moveTo((w*this.design[0].x), (h*this.design[0].y));
    for(var i=1;i<this.design.length;i++)
    {
      ctx.lineTo((w*this.design[i].x), (h*this.design[i].y));
    }
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  
    ctx.fillStyle="rgba("+this.color+","+this.alpha+")";
    ctx.textAlign = 'center'
    ctx.fillText(this.type, 0, 0 - 10);

    ctx.fillStyle="rgba("+this.color+","+(this.alpha/2)+")";
    ctx.fillRect(
      -this.width/2 + 10,
      10,
      this.width-20,
      10
    )
    ctx.fillStyle="rgba("+this.color+","+this.alpha+")";
    ctx.fillRect(
      -this.width/2 + 10,
      10,
      (this.width-20)*(this.HP/this.HPmax),
      10
    )

    ctx.translate(-this.x, -this.y);
  }
  

  //test against all the bullets using the ship design as a blueprint for line line tests.
  this.collisionTest = function()
  {
    if(this.killedAt === null)
    {
      for(var i=0;i<GameBullets.bullets.length;i++)
      {
        var bullet = GameBullets.bullets[i];
        var distance = Math.pow(Math.pow(Math.abs(this.x - bullet.x),2) + Math.pow(Math.abs(this.y - bullet.y),2),0.5)
        if(
          distance < this.collidableSphereRad &&  
          this.faction != bullet.faction
        )
        {
          this.collide(bullet);
        }
      }
    }
  }

  this.collide = function(bullet)
  {
    //decrement HPs, show damage numbers, kill if dead.
    var dmg = Math.floor(bullet.damage * bullet.alpha); //todo add armor 
    
    this.HP = this.HP - dmg; 
    
    bullet.HP = 0;
    GameViewDamageText.addDamageText(this, bullet, dmg);
  }

  this.logic = function()
  {
    this.collisionTest();

    if(this.HP <= 0)
    {
      this.kill();
    }

    // dead bases.
    if(this.killedAt !== null)
    {
      if(GameModel.stats.computedFrames - this.killedAt < this.deathAnimLength)
      {
        var animProportion = ((GameModel.stats.computedFrames - this.killedAt) / this.deathAnimLength)
        this.alpha = Math.round(Math.pow(Math.cos(0.5* Math.PI * animProportion),2)*1000)/1000;
      } else {
        this.alpha = 0;
      }
    }
  }

  this.kill=function()
  {
    if(this.killedAt === null) //else already dead!
    {
      this.killedAt = GameModel.stats.computedFrames;
      this.alpha=1;
      GameNPCBases.alive[this.type] = false

      GameBigText.setText('',this.type+' has been lost','255,0,0',5);

      this.killSpecial();

    }
    //each frame of the death.

    if(GameModel.stats.computedFrames - this.killedAt < this.deathAnimLength)
    {
      var animProportion = ((GameModel.stats.computedFrames - this.killedAt) / this.deathAnimLength)
      this.alpha = Math.round(Math.pow(Math.cos(0.5* Math.PI * animProportion),2)*1000)/1000;

    for(i=0; i<this.design.length;i++)
    {
      vertex = this.design[i];
      theta = (Math.random()*20-10) * (Math.PI/180)

      vertex.x = vertex.x*Math.cos(theta)-vertex.y*Math.sin(theta) 
      vertex.y = vertex.x*Math.sin(theta)+vertex.y*Math.cos(theta)
      GameViewParticles.addThrust(this, vertex.x * this.width, vertex.y * this.height);
    }
    this.height = this.height * 0.98
    this.width = this.width * 0.98

    } else {
      this.alpha = 0;
    }
  }
  this.killSpecial=function()
  {
    if(this.type=='inhibitor')
    {
      GameModel.bases.enemyWaveTick = GameModel.bases.enemyWaveTick / 2 
    }
    if(this.type=='munitions')
    {
      for(var i=0;i<GameModel.bases.pickupDeath;i++)
      {
        GamePickups.munitionsRoll();
      }
    }
  }
}

var GameNPCBases = {
  index:{
    RADAR: -1,
    REPAIR: -1,
    MUNITIONS: -1,
    INHIBITOR: -1
  },
  bases:[],
  alive:{
    radar:true,
    repair:true,
    munitions:true,
    inhibitor:true
  },
  render:function(ctx)
  {
    for(var i=0;i<this.bases.length;i++)
    {
      this.bases[i].render(ctx);
    }
  },
  init:function()
  {    
    var baseList = ['radar', 'repair', 'munitions', 'inhibitor']
    var posList = [
      [200,   200],
      [-200,  200],
      [200,  -200],
      [-200, -200]
    ]
    while(baseList.length>0)
    {
      idx = Math.floor(Math.random()*baseList.length) 
      GameNPCBases.index[baseList[idx].toUpperCase()]=this.bases.length;
      this.bases.push(new GameNPCBase(posList[0][0], posList[0][1], 200, 200, '55,55,255',baseList[idx]));
      baseList.splice(idx, 1);
      posList.splice(0,1);
    }
  },
  logic:function()
  {
    //check if all dead.
    if(
      this.alive.radar==false &&
      this.alive.repair==false &&
      this.alive.munitions==false &&
      this.alive.inhibitor==false
    )
    {
      GamePlayer.ship.HP = 0;
      GameBigText.setText('game over','all bases were lost','255,0,0',10);
    }



    var i = this.bases.length;
    while (i--) {
      var base = this.bases[i];
      if(base.HP <= 0)
      {
        base.HP=0;
        if(base.alpha == 0)
        {
          //this.bases.splice(i, 1);

        }
      }
      base.logic();
    }
  }
}

var GameBulletType=function(name, damage, spread, velocity, decay, falloff, fireRate)
{
  this.name      = name
  this.damage    = damage
  this.spread    = spread
  this.velocity  = velocity
  this.decay     = decay
  this.falloff   = falloff
  this.fireRate  = (fireRate*GameModel.stats.MAX_FPS)
  this.lastFired = 0
  this.color     = "255,255,255" 
  this.HP        = 1; //binary alive/dead tracking.
}

//These are just baseline. Upgrades/enemy levels will buff these.
var GameBulletTypes = {
  none:       new GameBulletType('null',        0,   360,  1000, 0,    1,    1000),
  //
  normal:     new GameBulletType('normal',      30,  5,    10,   0.97, 0.2,  0.1),
  shotgun:    new GameBulletType('shotgun',     30,  30,   15,   0.97, 0.5,  0.03),
  sprayer:    new GameBulletType('sprayer',     60,  360,  30,   0.97, 0.5,  0.03),
  laser:      new GameBulletType('laser',       60,  0,    25,   0.97, 0.5,  0.03),
  decimator:  new GameBulletType('decimator',   40,  15,   25,   0.97, 0.1,  2),
  dual:       new GameBulletType('dual',        30,  5,    20,   0.97, 0.2,  0.1),
  triple:     new GameBulletType('triple',      30,  5,    30,   0.97, 0.2,  0.1),
  explosion:  new GameBulletType('explosion',   40,  360,  30,   0.92, 0.4,  0.1),
  sweeper:    new GameBulletType('sweeper',     20,  180,  10,   0.98, 0.05, 1.5),
  sonicboom:  new GameBulletType('sonicboom',   10,  60,   5,    0.99, 0.05, 0.5),
  //
  peashooter: new GameBulletType('peashooter',  10,  30,   8,    0.97, 0.3,  1),
  peatwo:     new GameBulletType('peatwo',      10,  40,   8,    0.97, 0.3,  1),
  peathree:   new GameBulletType('peathree',    10,  60,   8,    0.97, 0.3,  1),

}

var GameBullets={
  bullets:[],
  addBullet:function(ship, type)
  {
    var bulletRotation = ship.rot + (((Math.random()*type.spread)-(type.spread/2))/180*Math.PI)
    //TODO: Accept bullet type etc.
    this.bullets.push({
      faction: ship.faction,
      damage: type.damage, 
      type: type.name,
      x: ship.x,
      y: ship.y,
      xOffset: 0,
      yOffset: -ship.height/2,
      rot: bulletRotation,
      velocityX: type.velocity * Math.sin(bulletRotation) + ship.velocityX, 
      velocityY: type.velocity * -Math.cos(bulletRotation) + ship.velocityY,
      color: ship.color,
      alpha: 1,
      decay: type.decay,
      falloff: type.falloff,
      size: 10
    })
  },
  render:function(ctx)
  {
    GameView.renderModeGame();
    var i = this.bullets.length
    while (i--) {
      bullet = this.bullets[i];
      ctx.fillStyle = "rgba("+bullet.color+","+bullet.alpha+")"
      ctx.translate(bullet.x, bullet.y);
      ctx.rotate(bullet.rot);
      ctx.fillRect(
        bullet.xOffset-0.5,
        bullet.yOffset-0.5,
        2,
        bullet.size
      )
      ctx.rotate(-bullet.rot);
      ctx.translate(-bullet.x, -bullet.y);
    }
  },
  logic:function()
  {
    var i = this.bullets.length
    while (i--) {
      bullet = this.bullets[i]
      bullet.alpha = bullet.alpha * bullet.decay
      bullet.x = bullet.x + bullet.velocityX//*Math.sin(bullet.rot);
      bullet.y = bullet.y + bullet.velocityY//*-Math.cos(bullet.rot);      
      if(bullet.alpha <= bullet.falloff)
      {
        this.bullets.splice(i, 1);
      } 
      else if(bullet.HP <= 0)
      {
        this.bullets.splice(i, 1);
      }
    }
  }
}

GameDirector={
  logic:function()
  {
    if(GameModel.stats.computedFrames % (GameModel.bases.enemyWaveTick) == 0)
    {
      //TODO: Levelled list of increasingly hard/frequent enemies!
      this.turn();
    }
  },
  turn:function()
  {

    GameModel.turnCount++;
    if(GameModel.turnCount % 10 == 0)
    {
      this.levelUp();
    }
    if(GameNPCBases.alive.munitions)
    {
      GamePickups.munitionsRoll();
      GamePickups.healthRoll();
    }
    
    this.spawnEnemies();
    if(GameNPCBases.alive.inhibitor == false)
    {
      this.spawnEnemies();
    }
  },
  levelUp:function()
  {
    GameBigText.setText('level up','base slightly repaired','0,255,0',2);
    for(i=0;i<GameNPCBases.bases.length;i++)
    {
      var base = GameNPCBases.bases[i];
      if(base.HP > 0)
      {
        base.HP = Math.min(base.HP + (base.HPmax*GameModel.bases.levelupRepair),base.HPmax);
      }
    }
  },
  spawnEnemies:function()
  {
    var enemiesSpawned = 0;
    enemiesSpawned += this.attemptSpawn('basic');  
    enemiesSpawned += this.attemptSpawn('fat');  
    enemiesSpawned += this.attemptSpawn('scion');  
    enemiesSpawned += this.attemptSpawn('shard');  
    
  },
  attemptSpawn:function(type)
  {
    var cfg = GameModel.enemies[type];
    var lvl = Math.floor(GameModel.turnCount/10)

    var qty    = cfg.initialQty    + (cfg.levelQty    * lvl)
    var chance = cfg.initialChance + (cfg.levelChance * lvl)

    //guaranteed.
    while(chance > 1)
    {
      chance = chance - 1
      for(var i=Math.ceil(Math.random()*qty);i>=1;i--)
      {
        GameEnemies.addEnemy(type,lvl);
      }
    }
    //check chance
    if(Math.random() < chance)
    {
      for(var i=Math.ceil(Math.random()*qty);i>=1;i--)
      {
        GameEnemies.addEnemy(type,lvl);
      }
    }

  }
}

var GameEnemies= {
  enemies:[],
  frame:function(ctx) {
    for(var i=0;i<this.enemies.length;i++)
    {
      this.enemies[i].frame(ctx);
    }
  },
  logic:function()
  {
    var i = this.enemies.length
    while (i--) {
      var enemy = this.enemies[i];
      if(enemy.ship.HP <= 0 && enemy.ship.alpha == 0)
      {
        //TODO: Loot.
        this.enemies.splice(i, 1);
      }

      this.enemies[i].logic();
    }

  },
  addEnemy:function(shipType, level)
  {
    //todo: flesh this out with types etc.
    enemy = new GameEnemy(shipType, level);
    //TODO: Apply level buffs.
    enemy.ship.equipMainWeapon(GameBulletTypes.peashooter);
    switch(shipType)
    {
      case 'scion':
        enemy.ship.equipMainWeapon(GameBulletTypes.peatwo);
      break;
      case 'shard':
        enemy.ship.equipMainWeapon(GameBulletTypes.peathree);
      break;
    }

    this.enemies.push(enemy);
  }
}

var GameEnemy=function(shipType, level){
  this.shipType = shipType || 'basic'
  this.level = level || 1 

  theta = Math.random()*2*Math.PI
  this.getTarget=function()
  {
    //TODO: Add targetting of the bases etc.
    if(Math.random()<0.7)
    {
      return GamePlayer.ship;
    }
    else
    {
      //attack a base.
      baseCount =  GameNPCBases.bases.length;
      return GameNPCBases.bases[Math.floor(Math.random()*baseCount)];
    }
  }
  this.target = this.getTarget();
  this.ship = new GameShip(
    (9000+Math.random()*1000)*Math.sin(theta),
    -(9000+Math.random()*1000)*Math.cos(theta),(theta+Math.PI),'255,0,0',this.shipType);
  //this.ship = new GameShip(100,100,-Math.PI,'ff0000','basic');
  this.frame=function(ctx)
  {
    this.ship.render(ctx);
  }
  this.logic=function()
  {
    this.ship.logic();
    //if target is dead pick a new one.
    if(this.target.killedAt !== null)
    {
      this.getTarget();
    }


    //Simple follow AI.
    targetDeltaX = this.ship.x - this.target.x;
    targetDeltaY = this.ship.y - this.target.y;
    theta = Math.atan2(targetDeltaX, targetDeltaY);

    diff = theta - this.ship.velocityAngle() + Math.PI;
    if(diff > Math.PI)
    {
      diff = diff - 2*Math.PI
    }

    if(Math.random()<0.3)
    {
      this.ship.thrust();
    }

    if(diff>(5 * Math.PI)/180 && Math.random()<1)
    {
      this.ship.rotate(this.ship.ROTATE_LEFT)
    }
    else if(diff<(-5 * Math.PI)/180 && Math.random()<1)
    {
      this.ship.rotate(this.ship.ROTATE_RIGHT)
    }

    if(Math.abs(diff)<30 && (Math.pow(Math.pow(targetDeltaX,2)+Math.pow(targetDeltaY,2),0.5))<1000)
    {
      this.ship.fire();
    }
  }
  
}

var GamePickup= function(x, y, w, h, color, type, faction, magnitude){
  this.HP = 1; //binary tracking of state.
  this.x = x;
  this.y = y;
  this.rot = 0;
  this.width = w || 10;
  this.baseWidth = this.width;
  this.height = h || 10;
  this.baseHeight = this.height;
  this.collidableSphereRad = (h); //generousity :D
  this.color = color;
  this.alpha = 1; //cloak?
  this.faction = faction || 'good';
  this.type = type || 'empty'
  this.magnitude = magnitude; //used to store currency amounts etc.

  //pickups drift in a random direction by total of 0.5px velocity
  this.velocityDirection = Math.random()* 2* Math.PI;
  this.velocityX = Math.cos(this.velocityDirection) * 0.5;
  this.velocityY = Math.sin(this.velocityDirection) * 0.5;

  this.design = [
    { x:-0.5,  y:-0.5  },
    { x:-0.5,  y: 0.5  },
    { x: 0.5,  y: 0.5  },
    { x: 0.5,  y:-0.5  },
    //x
    { x:-0.5,  y: 0.5  },
    { x: 0.5,  y: 0.5  },
    { x:-0.5,  y:-0.5  },
  ];

  this.render = function(ctx)
  {
    GameView.renderModeGame();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.rot);

    ctx.fillStyle="rgba(0,0,0,"+this.alpha+")";
    ctx.strokeStyle="rgba("+this.color+","+this.alpha+")";
    
    w = this.width
    h = this.height
    
    ctx.beginPath();
    ctx.moveTo((w*this.design[0].x), (h*this.design[0].y));
    for(var i=1;i<this.design.length;i++)
    {
      ctx.lineTo((w*this.design[i].x), (h*this.design[i].y));
    }
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    //backup the box

    ctx.strokeRect(
      -this.width/2,
      -this.height/2,
      this.width,
      this.height
    );
    
    ctx.rotate(-this.rot);

    //text
    ctx.fillStyle="rgba("+this.color+","+(((Math.sin(this.rot)+1)/4)+0.5)+")";
    ctx.textAlign = 'center'
    ctx.fillText(this.type, 0, 0 - 15);

    ctx.translate(-this.x, -this.y);
  }
  this.logic = function()
  {
    this.rot += 3*Math.PI/180
    this.width = this.baseWidth + Math.pow(Math.cos(this.rot*4),3)*3
    this.height = this.baseHeight + Math.pow(Math.cos(this.rot*4),3)*3
    this.x = this.x + this.velocityX;
    this.y = this.y + this.velocityY;
  }
  this.apply=function(ship)
  {
    switch(this.type) 
    {
      case 'shotgun':
      case 'sprayer':
      case 'laser':
      case 'decimator':
      case 'dual':
      case 'triple':
      case 'explosion':
      case 'sweeper':
      case 'sonicboom':
        this.applyWeapon(ship, type);
      break;
      case 'health':
        this.applyHealth(ship);
      break;
      case 'red':
      case 'blue':
      case 'green':
        this.applyCurrency(ship);
      break;
    }
  }
  this.applyWeapon=function(ship, name)
  {
    var ammo = GamePickups.ammo[name].base + Math.random()*GamePickups.ammo[name].rand;
    ship.equipAuxWeapon(GameBulletTypes[name],ammo);
  }
  this.applyHealth=function(ship)
  {
    var amt = GameModel.bases.healBase + (GameModel.bases.healLevel * Math.floor(GameModel.turnCount/10))
    amt = Math.ceil(Math.random()*amt);
    //heal and icon
    ship.HP= ship.HP + amt;
    ship.HP = Math.min(ship.HP, ship.HPmax);
    GameViewDamageText.addDamageText(ship, ship, '+ '+amt);
  }
  this.applyCurrency=function(ship)
  {
    var amt = this.magnitude
    if(ship.faction == 'good')
    {
      GameState.currency[this.type] += amt
    }
    GameViewDamageText.addDamageText(ship, ship, this.type[0].toUpperCase()+' x '+amt);
  }
}

var GamePickups = {
  pickups:[],
  ammo:{
    shotgun:{
      base: 250,
      rand: 125
    },
    sprayer:{
      base: 30,
      rand: 30
    },
    laser:{
      base: 50,
      rand: 100
    },
    decimator:{
      base: 3,
      rand: 10
    },
    dual:{
      base: 60,
      rand: 30
    },
    triple:{
      base: 50,
      rand: 20
    },
    explosion:{
      base: 1,
      rand: 1
    },
    sweeper:{
      base: 3,
      rand: 10
    },
    sonicboom:{
      base: 10,
      rand: 10
    }

  },
  render:function(ctx)
  {
    for(var i=0;i<this.pickups.length;i++)
    {
      this.pickups[i].render(ctx);
    }
  },
  init:function()
  {    
    this.healthRoll();
    this.munitionsRoll();
  },
  munitionsRoll:function()
  {
    var dropCount=0;

    if(Math.random()<GameModel.bases.pickups.shotgun)
    {
      this.drop('shotgun');
      dropCount++;
    }
    if(Math.random()<GameModel.bases.pickups.sprayer)
    {
      this.drop('sprayer');
      dropCount++;
    }
    if(Math.random()<GameModel.bases.pickups.laser)
    {
      this.drop('laser');
      dropCount++;
    }
    if(Math.random()<GameModel.bases.pickups.decimator)
    {
      this.drop('decimator');
      dropCount++;
    }
    if(Math.random()<GameModel.bases.pickups.dual)
    {
      this.drop('dual');
      dropCount++;
    }
    if(Math.random()<GameModel.bases.pickups.triple)
    {
      this.drop('triple');
      dropCount++;
    }
    if(Math.random()<GameModel.bases.pickups.explosion)
    {
      this.drop('explosion');
      dropCount++;
    }
    if(Math.random()<GameModel.bases.pickups.sweeper)
    {
      this.drop('sweeper');
      dropCount++;
    }
    if(Math.random()<GameModel.bases.pickups.sonicboom)
    {
      this.drop('sonicboom');
      dropCount++;
    }
    return dropCount;
  },
  healthRoll:function()
  {
    var dropCount=0;
    if(Math.random()<GameModel.bases.pickups.heal)
    {
      this.dropHealth('health');
      dropCount++;
    }
  },

  drop:function(pickupName)
  {
    this.pickups.push(new GamePickup(
      GameNPCBases.bases[GameNPCBases.index.MUNITIONS].x -40+(Math.random()*80),  
      GameNPCBases.bases[GameNPCBases.index.MUNITIONS].y,
      20, 20, '255,255,0',pickupName)
    );
  },
  dropHealth:function(pickupName)
  {
    this.pickups.push(new GamePickup(
      GameNPCBases.bases[GameNPCBases.index.REPAIR].x -40+(Math.random()*80),  
      GameNPCBases.bases[GameNPCBases.index.REPAIR].y,
      20, 20, '255,255,0',pickupName)
    );
  },
  dropResource:function(positionX, positionY, resource, magnitude)
  {
    var color = '';
    switch(resource)
    {
      case 'red':
        color = '255,0,0'
      break;
      case 'green':
        color = '0,255,0'
      break;
      case 'blue':
        color = '0,0,255'
      break;
    }

    this.pickups.push(new GamePickup(
      positionX,  
      positionY,
      20, 20, color, resource, 'good', magnitude)
    );
  },
  logic:function()
  {
    for(var i=0;i<this.pickups.length;i++)
    {
      this.pickups[i].logic();
    }
  }
}

var GamePlayer = { 
  ship:null,
  init:function()
  {
    this.ship = new GameShip(0,0,0,"0,255,0",null,"good")
    this.ship.equipMainWeapon(GameBulletTypes.normal);
    this.ship.deathAnimLength = 300;
  },
  render:function(ctx)
  {
    this.ship.render(ctx)
  },
  logic:function()
  {
    if(GameModel.input.keyboard.a || GameModel.input.keyboard.left_arrow)
    {
      this.ship.rotate(this.ship.ROTATE_LEFT);
    }
    if(GameModel.input.keyboard.d || GameModel.input.keyboard.right_arrow)
    {
      this.ship.rotate(this.ship.ROTATE_RIGHT);
    }
    if(GameModel.input.keyboard.w || GameModel.input.keyboard.up_arrow)
    {
      this.ship.thrust();
    }
    if(GameModel.input.keyboard.s || GameModel.input.keyboard.down_arrow)
    {
      this.ship.reverse_thrust();
    }
    if(GameModel.input.keyboard.space)
    {
      this.ship.fire();
    }
    this.ship.logic();
    if(this.ship.HP <= 0)
    {
      this.ship.HP = 0;
      if(GameBigText.show == false) { //no other reason for g.o., must have been death
        GameBigText.setText('game over','your ship is now scrap','255,0,0',10);
      }
      if(this.ship.alpha == 0)
      {
        GameState.setGameOver();
      }
    }

    
  }

}

var GameShip = function(x, y, rot, color, type, faction){
  this.ROTATE_LEFT = -1;
  this.ROTATE_RIGHT = 1;
  this.x = x;
  this.y = y;
  
  this.faction = faction || "evil";
  this.auxAmmo = 0;
  
  this.killedAt = null;
  this.deathAnimLength = 60;
  this.rot = rot;
  this.color = color || "255,255,255";
  this.alpha = 1; //cloak?
  this.type = type || 'basic';
  this.turnSpeed=0;
  this.baseMaxThrust=0;
  this.reverseMultiplier = 0.1;

  this.weapons = {
    main: JSON.parse(JSON.stringify(GameBulletTypes.none)), //deep clone
    aux: JSON.parse(JSON.stringify(GameBulletTypes.none))
  }

  switch(this.type)
  {
    case 'basic':
      this.width = 20;
      this.height = 30;
      this.collidableSphereRad = 13
      this.HP = 100;
      this.turnSpeed = 0.3; //degrees to turn 
      this.baseMaxThrust = 30
      this.thrustStep = 0.2;
      this.dragStep = 0.007;

      this.design = [
        { x:-0.5,  y: 0.5  },
        { x: 0,    y:-0.5  },
        { x: 0.5,  y: 0.5  },
        { x: 0,    y: 0.25 },
        { x:-0.5,  y: 0.5 },
      ];
    break;

    case 'fat':
      this.width = 40;
      this.height = 30;
      this.collidableSphereRad = 18
      this.HP = 200;
      this.turnSpeed = 0.05; //degrees to turn 
      this.baseMaxThrust = 20
      this.thrustStep = 0.3;
      this.dragStep = 0.008;
      this.design = [
        { x:-0.5,  y: 0.5  },
        { x: 0,    y:-0.5  },
        { x: 0.5,  y: 0.5  },
        { x: 0,    y: 0.25 },
        { x:-0.5,  y: 0.5 },
      ];
    break;
    case 'scion':
      this.width = 30;
      this.height = 45;
      this.collidableSphereRad = 18
      this.HP = 250;
      this.turnSpeed = 0.1; //degrees to turn 
      this.baseMaxThrust = 30
      this.thrustStep = 0.5;
      this.dragStep = 0.01;
      this.design = [
        { x:-0.5,   y: 0    },
        { x:-0.25,  y: 0.5  },
        { x:-0.05,  y: 0.3  },
        { x:0.05,   y: 0.3  },
        { x:0.25,   y: 0.5  },
        { x:0.5,    y: 0    },
        { x:0,      y: -0.5 }
      ];
    break;
    case 'shard':
      this.width = 45;
      this.height = 135;
      this.collidableSphereRad = 30
      this.HP = 250;
      this.turnSpeed = 0.1; //degrees to turn 
      this.baseMaxThrust = 4
      this.thrustStep = 0.2;
      this.dragStep = 0.01;
      this.design = [
        { x:-0.5,   y: 0    },
        { x:-0.05,  y: 0.3  },
        { x:0.05,   y: 0.3  },
        { x:0.5,    y: 0    },
        { x:0,      y: -0.5 }
      ];
    break;


  }
  this.HPmax = this.HP;
  this.auxAmmoMax = this.auxAmmo;

  this.maxThrust = this.baseMaxThrust; 


  this.velocityX = 0;
  this.velocityY = 0;
  this.equipMainWeapon = function(weapon)
  {
    this.weapons.main = JSON.parse(JSON.stringify(weapon));
  }
  this.equipAuxWeapon = function(weapon,ammo)
  {
    this.auxAmmo = ammo;
    this.auxAmmoMax = ammo;
    this.weapons.aux = JSON.parse(JSON.stringify(weapon));
  }
  this.velocity = function()
  {
    v = Math.pow(Math.pow(this.velocityX,2) + Math.pow(this.velocityY, 2),0.5);
    return v
  }

  this.velocityAngle = function()
  {
    theta = Math.atan2(this.velocityX, this.velocityY);
    if(isNaN(theta)) { theta = 0 }
    return theta;
  }

  

  this.render = function(ctx)
  {
    GameView.renderModeGame();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.rot);

    ctx.fillStyle="rgba(0,0,0,"+this.alpha+")";
    ctx.strokeStyle="rgba("+this.color+","+this.alpha+")";
    
    w = this.width
    h = this.height

    
    ctx.beginPath();
    ctx.moveTo((w*this.design[0].x), (h*this.design[0].y));
    for(var i=1;i<this.design.length;i++)
    {
      ctx.lineTo((w*this.design[i].x), (h*this.design[i].y));
    }
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
 
    ctx.rotate(-this.rot);
    ctx.translate(-this.x, -this.y);
  }

  //test against all the bullets using the ship design as a blueprint for line line tests.
  this.collisionTest = function()
  {
    if(this.killedAt === null)
    {
      for(var i=0;i<GameBullets.bullets.length;i++)
      {
        var bullet = GameBullets.bullets[i];
        var distance = Math.pow(Math.pow(Math.abs(this.x - bullet.x),2) + Math.pow(Math.abs(this.y - bullet.y),2),0.5)
        if(
          distance < this.collidableSphereRad &&  
          this.faction != bullet.faction
        )
        {
          this.collide(bullet);
        }
      }
      var i = GamePickups.pickups.length
      while(i--)
      {
        var pickup = GamePickups.pickups[i];
        var distance = Math.pow(Math.pow(Math.abs(this.x - pickup.x),2) + Math.pow(Math.abs(this.y - pickup.y),2),0.5)
        if(
          distance < pickup.collidableSphereRad
        )
        {
          if(this.faction != pickup.faction)
          {
            GameViewDamageText.addDamageText(this, pickup, 'theft!');
          }
          this.getPickup(pickup);
          GamePickups.pickups.splice(i, 1)
        }
      }

    }
  }

  this.collide = function(bullet)
  {
    //decrement HPs, show damage numbers, kill if dead.
    var dmg = Math.floor(bullet.damage * bullet.alpha); //todo add armor 
    
    this.HP = this.HP - dmg; 
    
    bullet.HP = 0;
    GameViewDamageText.addDamageText(this, bullet, dmg);
  }

  this.getPickup = function(pickup)
  {
    pickup.apply(this);

  }

  this.logic = function()
  {

    if(this.HP <= 0)
    {
      this.kill();
    }

    //be nice about angles so the AI doesn't derp.
    if(this.rot > Math.PI)
    {
      this.rot=(this.rot - Math.PI*2)
    } 
    else if(this.rot < -Math.PI)
    {
      this.rot=(this.rot + Math.PI*2)
    }

    // velocity decay
    var total = this.velocity() * (1- this.dragStep)
    var newX = (Math.sin(this.velocityAngle()) * total);
    var newY = (Math.cos(this.velocityAngle()) * total);
   
    if(!isNaN(newX) && !isNaN(newY))
    {
      this.velocityX = newX;
      this.velocityY = newY;
    }
    this.x = this.x + this.velocityX;
    this.y = this.y + this.velocityY;
    this.collisionTest();
  }

  // direction should be 1 or -1 (cw/anticw.)
  // highervalues allow for faster rotation
  this.rotate = function(direction)
  {
    rotationAmount = (this.turnSpeed * direction * (2*Math.PI) / GameModel.stats.MAX_FPS)
    this.rot = this.rot + rotationAmount;
  }
  this.thrust = function()
  {
    //calculate 
    currentVelocity = this.velocity();
    newX = Math.sin(this.rot)*this.thrustStep;
    newY = -Math.cos(this.rot)*this.thrustStep;
    this.velocityX = this.velocityX + newX;
    this.velocityY = this.velocityY + newY;
    if(GameModel.stats.computedFrames % 6 == 0)
    {
      GameViewParticles.addThrust(this);
    }
  }
  this.reverse_thrust = function()
  {
    //calculate 
    currentVelocity = this.velocity();
    newX = -Math.sin(this.rot)*this.thrustStep*this.reverseMultiplier;
    newY = Math.cos(this.rot)*this.thrustStep*this.reverseMultiplier;
    this.velocityX = this.velocityX + newX;
    this.velocityY = this.velocityY + newY;
  }
  this.fireMain = function()
  {
    if(GameModel.stats.computedFrames - this.weapons.main.lastFired > this.weapons.main.fireRate)
    {
      this.weapons.main.lastFired = GameModel.stats.computedFrames;
      GameBullets.addBullet(this, this.weapons.main);
    }
  }
  this.fireAux = function()
  {
    if(GameModel.stats.computedFrames - this.weapons.aux.lastFired > this.weapons.aux.fireRate)
    {
      this.auxAmmo--;
      this.weapons.aux.lastFired = GameModel.stats.computedFrames;
      
      var bulletCount = 1;
      
      switch(this.weapons.aux.name) {
        case 'dual':
        case 'peatwo':
          bulletCount = 2;
        break;
        case 'triple':
        case 'peathree':
          bulletCount = 3;
        break;
        case 'sprayer':
          bulletCount = 4;
        break;
        case 'sonicboom':
          bulletCount = 30;
        break;
        case 'sweeper':
          bulletCount = 30;
        break;
        case 'decimator':
          bulletCount = 15;
        break;
        case 'explosion':
          bulletCount = 100;
        break;
      }

      for(var i=0;i<bulletCount;i++)
      {
        GameBullets.addBullet(this, this.weapons.aux);
      }
    }
  },
  this.fire = function()
  {
    if(this.auxAmmo > 0)
    {
      this.fireAux();
    } else {
      this.fireMain();
    }
  },
  this.kill=function()
  {
    if(this.killedAt === null) //else already dead!
    {
      this.killedAt = GameModel.stats.computedFrames;
      this.alpha=1;
      this.thrustStep = 0;
      this.turnSpeed = 0;
      //this.faction = 'zombie'
      this.weapons.main = GameBulletTypes.none 
      if(this.faction == 'evil')
      {
        this.attemptDrops();
      }
    }
    

    //each frame of the death.
    if(GameModel.stats.computedFrames - this.killedAt < this.deathAnimLength)
    {
      var animProportion = ((GameModel.stats.computedFrames - this.killedAt) / this.deathAnimLength)
      this.alpha = Math.round(Math.pow(Math.cos(0.5* Math.PI * animProportion),2)*1000)/1000;
    } else {
      this.alpha = 0;
    }

    if(GameModel.stats.computedFrames % 3 == 0)
    {
      GameViewParticles.addThrust(this);
    }

    for(i=0; i<this.design.length;i++)
    {
      vertex = this.design[i];
      theta = (Math.random()*20-10) * (Math.PI/180)

      vertex.x = vertex.x*Math.cos(theta)-vertex.y*Math.sin(theta) 
      vertex.y = vertex.x*Math.sin(theta)+vertex.y*Math.cos(theta)

    }

    this.rot = this.rot + 9 * Math.PI / 180;
    this.height = this.height * 0.98
    this.width = this.width * 0.98
  }
  this.attemptDrops=function()
  {
    var data = GameModel.enemies[this.type].drop
    var dropTypes = ['red','green','blue'];

    for(var i=0;i<dropTypes.length;i++)
    {
      var obj = data[dropTypes[i]]
      if(Math.random() < obj.chance)
      {
        var lvl = Math.floor(GameModel.turnCount/10) + 1;
        var amt = obj.amount + Math.random(
          obj.amountRandom + 
          lvl*obj.amountLevel + 
          lvl*lvl*obj.amountLevelSquared
        )
        GamePickups.dropResource(this.x, this.y, dropTypes[i], Math.floor(amt))
      }
    }

  }
}

</script>